# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    note.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: xuluu <marvin@42.fr>                       +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/07/11 17:01:16 by xuluu             #+#    #+#              #
#    Updated: 2023/07/11 17:19:32 by xuluu            ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

link
	microshell --> use pipe for [pwd | grep h | wc -c]
		https://github.com/shackbei/microshell-42/blob/main/microshell.c

1.
	<< limuted
		--> fork()
	> file or < file ... 
		--> fork() + dup2()
	pwd or ls ...
		--> fork() + pipe() + dup2()

2.
	dup2(fd, 1) --> pwd > file
	dup2(fd, 0) --> pwd < file

3.
	&&
		La seconde commande (commande2) est exécutée uniquement
		si le code de retour de la commande (commande1) est égale à 0 (vrai).
	||
		La seconde commande (commande2) est exécutée uniquement
		si le code de retour de la commande (commande1) est égale à 1 (faux).
	
4.
	&& &&
		[V] [V] [V]
		[X] [X] [X]
	|| ||
		[X] [V] [X]
		[V] [X] [X]
	&& ||
		[V] [V] [X]
		[X] [X] [V]
	|| &&
		[V] [X] [V]
		[X] [V] [V]

5.
	[first] [*]       --> find str start with first
	[*] [end]         --> find str end with end
	[*] [center] [*]  --> find small_str in big_str

	[first] [*] [center] [*] [end]
	--> find [center]
	--> find [first]
	--> fins [end]

6.
	* C *

	F *
	F * C *

	* E
	* C * E

	F * E
	F * C * E

7.
	chaque Fork() a pid_t id
	1 fork == 1 pid_t
	5 fork == 5 pid_t
	...

	close tout les fd apres utiliser

	stdin --> CAT --> fd[1] --> fd[0] --> CAT --> fd[1] --> fd[0] --> ls
	fd[0] == stdin

	cat | cat | ls
	--> 3 Fork()
	fork1:
		stdin
		dup2(fd[1], Stdout);
	fork2:
		dup2(fd[0], Stdin);
		dup2(fd[1], Stdout);
	fork3:
		dup2(fd[0], Stdout);

8.
	chaque Fork() a pid_t id
	1 fork == 1 pid_t
	5 fork == 5 pid_t
	...

	close tout les fd apres utiliser

	stdin --> CAT --> fd[1] --> fd[0] --> CAT --> fd[1] --> fd[0] --> ls
	fd[0] == stdin

	cat | cat | ls
	--> 3 Fork()
	fork1:
		stdin
		dup2(fd[1], Stdout);
	fork2:
		dup2(fd[0], Stdin);
		dup2(fd[1], Stdout);
	fork3:
		dup2(fd[0], Stdout);

9.
	Creer 3e fd --> tmp_fd
	permet arreter de melanger l'ordre dans le pipe
	tmp_fd = dup(STDIN_FILENO);
	fd[1] --> fd[0];
	tmp_fd = fd[0];

10.
	execute les commandes dans le process enfant
	wait tous les process enfant dans le parent
	mettre pipe(fd) dans la boucle du process enfant
		--> permet chaque process enfant qui peut
			lire dans dup2(tmp_fd, 0)
			ecrit dans dup2(fd[1], 1)
	creer un tmp_fd
		--> permet tous les enfants execute dans 1 ordre (pas melanger)

11.
	$USER --> root
	"$USER" --> root
	"'$USER'" --> 'root'

	'$USER' --> $USER
	'"$USER"' --> "$USER"

12.
	<< e enter enter ok e
	<< e e
	< ''
	< ""
	"$?            $?"

13. file change
	ft_signe_dollar
	ft_redirection
	ft_error
	ft_utile
