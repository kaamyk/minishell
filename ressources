
####################      Short cut to Ctrl+F      ######################

readline	rl_clear_history	rl_on_new_line	rl_replace_line	signal	sigaction	sigemptyset		sigaddset	rl_redisplay	add_history	printf	malloc	free	write	access	open	read	close	fork	wait	waitpid	wait3	wait4	kill	exit	getcwd	chdir	stat	lstat	fstat	unlink	execve	dup	dup2	pipe	opendir	readdir	closedir	strerror	perror	isatty	ttyname	ttyslot	ioctl	getenv	tcsetattr	tcgetattr	tgetent	tgetflag	tgetnum		tgetstr	tgoto	tputs

##########################################################################

Man readline :
	https://tiswww.case.edu/php/chet/readline/readline.html

man history : (add_history() is one of the function of the library)
	https://linux.die.net/man/3/history

	#include  <readline/history.h>
	void add_history (const char *string);

man access() :
	https://man7.org/linux/man-pages/man2/access.2.html

	#include <unistd.h> 
	int access(const char *pathname, int mode);

	The mode specifies the accessibility check(s) to be performed,
	and is either the value F_OK, or a mask consisting of the bitwise
	OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the
	existence of the file.  R_OK, W_OK, and X_OK test whether the
	file exists and grants read, write, and execute permissions,
	respectively. 

man open() :
	http://manpagesfr.free.fr/man/man2/open.2.html

	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>

	int open(const char *pathname, int flags);
	int open(const char *pathname, int flags, mode_t mode);

	Opens a file and returns a file descriptor. The mode specifies the action authorized with the file.

man read() :
	http://manpagesfr.free.fr/man/man2/read.2.html

	#include <unistd.h>
	ssize_t read(int fd, void *buf, size_t count);

	Reads count bytes in the fd, into buf.
	Returns -1 if fails.

man close() :
	http://manpagesfr.free.fr/man/man2/close.2.html

	#include <unistd.h>
	int	close(int fd);

	Closes the fd.
	Return -1 if fails.

man fork() :
	http://manpagesfr.free.fr/man/man2/fork.2.html

	#include <unistd.h>
	pid_t fork(void);

	Opens a new child process copied from the mother one.

man wait()/waitpid() :
	http://manpagesfr.free.fr/man/man2/wait.2.html

	#include <sys/types.h>
	#include <sys/wait.h>

	pid_t wait(int *status);
	pid_t waitpid(pid_t pid, int *status, int options);

	These functions are used to wait for a change in the state of a calling process. These changes can be : process finished, process interrupted by a sginal or process relaunched with a signal.
	wait() free ressources associates to the process.

man wait3() / wait4() :
	https://linux.die.net/man/2/wait3

	#include <sys/types.h>
	#include <sys/time.h>
	#include <sys/resource.h>
	#include <sys/wait.h>

	pid_t wait3(int *status, int options,
	            struct rusage *rusage);
	pid_t wait4(pid_t pid, int *status, int options,
	            struct rusage *rusage);

	The man tells us that these functions are obsolete and it is better to use wait and waitpid.

	Other than the use of the rusage argument, the following wait3() call:
	wait3(status, options, rusage);
	is equivalent to:
	waitpid(-1, status, options);

	Similarly, the following wait4() call:
	wait4(pid, status, options, rusage);
	is equivalent to:
	waitpid(pid, status, options);

man signal :
	http://manpagesfr.free.fr/man/man2/signal.2.html

	It is recommanded to use sigaction because the behaviour of these function changes following the Unix version we are using and the date of it.

man sigaction :
	http://manpagesfr.free.fr/man/man2/sigaction.2.html

	#include <signal.h>
	int sigaction(int signum, const struct sigaction *act,
	              struct sigaction *oldact);

	sigaction() changes the behaviour of a processus sollowing the signal received.

man sigemptyset() / sigaddset() :
	https://linux.die.net/man/3/sigemptyset

	#include <signal.h>
	int	segemptyset(sigset_t *set);
	int	sigaddset(sigset_t *set, int signum);

	These functions allow the manipulation of POSIX signal sets.
	sigemptyset() initializes the signal set given by set to empty, with all signals excluded from the set.
	sigaddset() add signal signum from set. 

man kill() :
	https://man7.org/linux/man-pages/man2/kill.2.html

	#include <signal.h>
	int kill(pid_t pid, int sig);

	kill() sends a signal sig to a pid.

man exit() :
	http://manpagesfr.free.fr/man/man3/exit.3.html

	#include <stdlib.h>
	void exit(int status);

	exit() quit and finishes the process and sends the status value to the parent process.
	No return value;

man getcwd() :
	https://linux.die.net/man/3/getcwd

	#include <unistd.h>
	char *getcwd(char *buf, size_t size);

	getcwd() copies an absolute pathname of the current working directory to the array pointed by buf, wich is of lenght size.

man chdir() :
	https://linux.die.net/man/3/chdir

	#include <unistd.h>
	int chdir(const char *path);

	The chdir() function shall cause the directory named by the pathname pointed to by the path argument to become the current working directory; that is, the starting point for path searches for pathnames not beginning with '/'.

man stat() / lstat() / fstat() :
	https://linux.die.net/man/2/stat

	#include <sys/types.h>
	#include <sys/stat.h>
	#include <unistd.h>

	int stat(const char *path, struct stat *buf);
	int fstat(int fd, struct stat *buf);
	int lstat(const char *path, struct stat *buf);

	These functions return information about a file. No permissions are required on the file itself, but-in the case of stat() and lstat() - execute (search) permission is required on all of the directories in path that lead to the file.
	-stat() stats the file pointed to by path and fills in buf.
	-lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.
	-fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd.
	These functions are linked to execve() , read(), write(), open(), and pipe().

man unlink() :
	https://linux.die.net/man/2/unlink

	#include <unistd.h>
	int unlink(const char *pathname);

	(Basically removes a file)
	unlink() deletes a name from the file system. If that name was the last link to a file and no processes have the file open the file is deleted and the space it was using is made available for reuse.
	If the name was the last link to a file but any processes still have the file open the file will remain in existence until the last file descriptor referring to it is closed.
	If the name referred to a symbolic link the link is removed.
	If the name referred to a socket, fifo or device the name for it is removed but processes which have the object open may continue to use it.

man execve() :
	https://linux.die.net/man/2/execve

	#include <unistd.h>
	int execve(const char *filename, char *const argv[], char *const envp[]);

	(Pretty long description)
	execve() executes the binary or executable filename with argv parameters (terminated by NULL). envp is an array of string passed as environment to the program.

man export() :
https://www.geeksforgeeks.org/export-command-in-linux-with-examples/